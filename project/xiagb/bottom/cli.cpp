#include "cli.hpp"
#include "task.h"
#include "string.h"
#include "stdio.h"
#include "math.h"

namespace xiagb
{
    namespace parserNamespace
    {
        namespace cliNamespace
        {
            const char *const echoCommandStr = "echo";
            typedef bool (*cmd_callback)(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
            bool cliClass::registerFlag;

            struct cmd
            {
                const char *const pcCommand;             /* The command that causes pxCommandInterpreter to be executed.  For example "help".  Must be all lower case. */
                const char *const pcHelpString;          /* String that describes how to use the command.  Should start with the command itself, and end with "\r\n".  For example "help: Returns a list of all the commands\r\n". */
                const cmd_callback pxCommandInterpreter; /* A pointer to the callback function that will return the output generated by the command. */
                int8_t cExpectedNumberOfParameters;      /* Commands expect a fixed number of parameters, which may be zero. */
            };

            struct cmd_list
            {
                const cmd *pxCommandLineDefinition;
                cmd_list *pxNext;
            };

            bool FreeRTOS_CLIProcessCommand(const char *const pcCommandInput, char *pcWriteBuffer, size_t xWriteBufferLen, const cmd_list *pxCommand);
            bool FreeRTOS_CLIRegisterCommand(const cmd *const pxCommandToRegister);
            int8_t prvGetNumberOfParameters(const char *pcCommandString);
            void vRegisterSampleCLICommands();

            bool prvHelpCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
            bool prvTaskStatsCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
            bool prvQueryHeapCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
            bool prvParameterEchoCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);

            const cmd xHelpCommand = {
                "help",
                "\r\nhelp:\r\n Lists all the registered commands.\r\n",
                prvHelpCommand,
                0};

            const cmd xTaskStats = {
                "task-stats", /* The command string to type. */
                "\r\ntask-stats:\r\n Displays a table showing the state of each FreeRTOS task.\r\n",
                prvTaskStatsCommand, /* The function to run. */
                0                    /* No parameters are expected. */
            };

            const cmd xQueryHeap = {
                "query-heap",
                "\r\nquery-heap:\r\n Displays the free heap space, and minimum ever free heap space.\r\n",
                prvQueryHeapCommand, /* The function to run. */
                0                    /* The user can enter any number of commands. */
            };

            const cmd xParameterEcho = {
                echoCommandStr,
                "\r\necho <...>:\r\n Take variable number of parameters, echos each in turn.\r\n",
                prvParameterEchoCommand, /* The function to run. */
                -1                       /* The user can enter any number of commands. */
            };

            cmd_list xRegisteredCommands = {
                &xHelpCommand,
                NULL};

            const char *const welcomeStr = "FreeRTOS command server.\r\nType Help to view a list of registered commands.\r\n\r\n>";
            const char *const endStr = "\r\n[Press ENTER to execute the previous command again]\r\n>";
            const char *const newLineStr = "\r\n";

            osMessageQueueId_t echoDataQueue;

            cliClass::cliClass()
            {
            }

            cliClass::~cliClass()
            {
            }

            void cliClass::init(uartClass *uartHandle)
            {
                this->uartHandle = uartHandle;

                mutex = osMutexNew(nullptr);
                while (mutex == 0)
                    ;

                rxQueue = osMessageQueueNew(rxQueueCount, sizeof(uint8_t), nullptr);
                while (rxQueue == 0)
                    ;

                inputBuffer = new uint8_t[inputBufferSize];
                while (inputBuffer == 0)
                    ;
                lastCommandBuffer = new uint8_t[inputBufferSize];
                while (lastCommandBuffer == 0)
                    ;
                outputBuffer = new uint8_t[outputBufferSize];
                while (outputBuffer == 0)
                    ;

                outputStr((uint8_t *)welcomeStr); //欢迎语

                //注册命令
                vRegisterSampleCLICommands();
            }

            void cliClass::outputChar(uint8_t data)
            {
                if (uartHandle && feedbackFlag)
                    uartHandle->send(&data, 1);
            }

            void cliClass::outputStr(uint8_t *data)
            {
                // while (*data)
                // {
                //     outputChar(*data);
                //     data++;
                // }
                if (uartHandle && feedbackFlag)
                    uartHandle->send(data, strlen((const char *)data));
            }

            osStatus_t cliClass::getChar(uint8_t *pcRxedChar) { return osMessageQueueGet(rxQueue, pcRxedChar, nullptr, 0); }
            void cliClass::setChar(uint8_t *data) { osMessageQueuePut(rxQueue, data, 0, osWaitForever); }
            void cliClass::setEchoQueue(osMessageQueueId_t argQueueI32)
            {
                echoDataQueue = argQueueI32;
            }

            // void cliClass::setStr(uint8_t *data, uint16_t size)
            // {
            //     osMutexAcquire(mutex, osWaitForever);
            //     for (uint16_t i = 0; i < size; i++)
            //     {
            //         setChar(&data[i]);
            //     }
            //     osMutexRelease(mutex);
            // }

            void cliClass::receiveQueueStr(osMessageQueueId_t queue)
            {
                uint8_t buffer;
                while (osMessageQueueGet(queue, &buffer, nullptr, 0) == osOK) //数据都是提前准备好的，所以超时是0
                {
                    setChar(&buffer);
                }
            }

            void cliClass::loop()
            {
                uint8_t buffer;
                while (getChar(&buffer) == osOK)
                {
                    /* Echo the character back. */
                    outputChar(buffer);

                    /* Was it the end of the line? */
                    if (buffer == '\n' || buffer == '\r')
                    {
                        /* Just to space the output from the input. */
                        outputStr((uint8_t *)newLineStr);

                        /* See if the command is empty, indicating that the last command
            is to be executed again. */
                        if (inputBufferIndex == 0)
                        {
                            /* Copy the last command back into the input string. */
                            strcpy((char *)inputBuffer, (char *)lastCommandBuffer);
                        }

                        /* Pass the received command to the command interpreter.  The
            command interpreter is called repeatedly until it returns
            pdFALSE	(indicating there is no more output) as it might
            generate more than one string. */
                        bool xReturned;
                        const cmd_list *pxCommand = nullptr; //重复执行时记住命令，避免重复查找命令
                        do
                        {
                            /* Get the next output string from the command interpreter. */
                            xReturned = FreeRTOS_CLIProcessCommand((char *)inputBuffer, (char *)outputBuffer, outputBufferSize, pxCommand);

                            /* Write the generated string to the UART. */
                            outputStr(outputBuffer);

                        } while (xReturned != pdFALSE); //有的命令需要多次执行，因为有些东西可以是无限的，比如某些命令的参数，命令数量，一次执行可能会爆输出缓存

                        /* All the strings generated by the input command have been
            sent.  Clear the input string ready to receive the next command.
            Remember the command that was just processed first in case it is
            to be processed again. */
                        strcpy((char *)outputBuffer, (char *)inputBuffer);
                        inputBufferIndex = 0;
                        memset(inputBuffer, 0x00, inputBufferSize);

                        outputStr((uint8_t *)endStr);
                    }
                    else
                    {
                        if (buffer == '\r')
                        {
                            /* Ignore the character. */
                        }
                        else if ((buffer == '\b') || (buffer == 0x7f)) //0x7f为退格键
                        {
                            /* Backspace was pressed.  Erase the last character in the
                string - if any. */
                            if (inputBufferIndex > 0)
                            {
                                inputBufferIndex--;
                                inputBuffer[inputBufferIndex] = '\0';
                            }
                        }
                        else
                        {
                            /* A character was entered.  Add it to the string entered so
                far.  When a \n is entered the complete	string will be
                passed to the command interpreter. */
                            if ((buffer >= ' ') && (buffer <= '~'))
                            {
                                if (inputBufferIndex < inputBufferSize)
                                {
                                    inputBuffer[inputBufferIndex] = buffer;
                                    inputBufferIndex++;
                                }
                            }
                        }
                    }
                }
            }

            //添加命令
            //全局只执行一次
            bool FreeRTOS_CLIRegisterCommand(const cmd *const pxCommandToRegister)
            {
                static cmd_list *pxLastCommandInList = &xRegisteredCommands; //每运行一次，pxLastCommandInList将指向最新的那个元素，以便下次添加
                bool xReturn = pdFAIL;

                /* Check the parameter is not NULL. */
                configASSERT(pxCommandToRegister);

                /* Create a new list item that will reference the command being registered. */
                // cmd_list *pxNewListItem = (cmd_list *)pvPortMalloc(sizeof(cmd_list));
                cmd_list *pxNewListItem = new cmd_list;
                configASSERT(pxNewListItem);

                if (pxNewListItem != NULL)
                {
                    taskENTER_CRITICAL();
                    {
                        /* Reference the command being registered from the newly created
                list item. */
                        pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;

                        /* The new list item will get added to the end of the list, so
                pxNext has nowhere to point. */
                        pxNewListItem->pxNext = NULL;

                        /* Add the newly created list item to the end of the already existing
                list. */
                        pxLastCommandInList->pxNext = pxNewListItem;

                        /* Set the end of list marker to the new list item. */
                        pxLastCommandInList = pxNewListItem;
                    }
                    taskEXIT_CRITICAL();

                    xReturn = pdPASS;
                }

                return xReturn;
            }

            //找命令，找到就执行。有的命令需要多次执行
            bool FreeRTOS_CLIProcessCommand(const char *const pcCommandInput, char *pcWriteBuffer, size_t xWriteBufferLen, const cmd_list *pxCommand)
            {
                bool xReturn = pdTRUE;
                const char *pcRegisteredCommandString;
                size_t xCommandStringLength;

                /* Note:  This function is not re-entrant.  It must not be called from more
        thank one task. */

                if (pxCommand == NULL)
                {
                    //遍历命令列表
                    for (pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext)
                    {
                        //列表里的命令字符串
                        pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
                        //该字符串长度
                        xCommandStringLength = strlen(pcRegisteredCommandString);

                        /* To ensure the string lengths match exactly, so as not to pick up
                a sub-string of a longer command, check the byte after the expected
                end of the string is either the end of the string or a space before
                a parameter. */
                        if ((pcCommandInput[xCommandStringLength] == ' ') || (pcCommandInput[xCommandStringLength] == 0x00))
                        {
                            //比较输入的和现存的命令是否相同
                            if (strncmp(pcCommandInput, pcRegisteredCommandString, xCommandStringLength) == 0)
                            {
                                /* The command has been found.  Check it has the expected
                        number of parameters.  If cExpectedNumberOfParameters is -1,
                        then there could be a variable number of parameters and no
                        check is made. */
                                if (pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0)
                                {
                                    if (prvGetNumberOfParameters(pcCommandInput) != pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters)
                                    {
                                        //参数数量不对
                                        xReturn = pdFALSE;
                                    }
                                }

                                break;
                            }
                        }
                    }
                }

                if ((pxCommand != NULL) && (xReturn == pdFALSE))
                {
                    /* 找到命令，但命令的参数数量是不正确的 */
                    strncpy(pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen);
                    pxCommand = NULL;
                }
                else if (pxCommand != NULL)
                {
                    /* 调用此命令中注册的回调函数。有的命令需要多次执行 */
                    xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter(pcWriteBuffer, xWriteBufferLen, pcCommandInput);

                    /* If xReturn is pdFALSE, then no further strings will be returned
            after this one, and	pxCommand can be reset to NULL ready to search
            for the next entered command. */
                    if (xReturn == pdFALSE)
                    {
                        pxCommand = NULL;
                    }
                }
                else
                {
                    /* 找不到命令 */
                    strncpy(pcWriteBuffer, "Command not recognised.  Enter 'help' to view a list of available commands.\r\n\r\n", xWriteBufferLen);
                    xReturn = pdFALSE;
                }

                return xReturn;
            }

            //从输入获取相应序号的字符串，也就是参数字符串
            const char *FreeRTOS_CLIGetParameter(const char *pcCommandString, UBaseType_t uxWantedParameter, BaseType_t *pxParameterStringLength)
            {
                UBaseType_t uxParametersFound = 0;
                const char *pcReturn = NULL;

                *pxParameterStringLength = 0;

                while (uxParametersFound < uxWantedParameter)
                {
                    /* 将指针定位到该单词结束 */
                    while (((*pcCommandString) != 0x00) && ((*pcCommandString) != ' '))
                    {
                        pcCommandString++;
                    }

                    /* 将指针定位到下一个单词的开始 */
                    while (((*pcCommandString) != 0x00) && ((*pcCommandString) == ' '))
                    {
                        pcCommandString++;
                    }
                    //第一次会掠过第一个单词也就是命令，并从下一个单词开始，就是第一个参数

                    /* Was a string found? */
                    if (*pcCommandString != 0x00)
                    {
                        /* Is this the start of the required parameter? */
                        uxParametersFound++;

                        //当前到的单词的序号是不是想要的那个序号？
                        if (uxParametersFound == uxWantedParameter)
                        {
                            /* 该单词的开始的位置 */
                            pcReturn = pcCommandString;
                            while (((*pcCommandString) != 0x00) && ((*pcCommandString) != ' '))
                            {
                                (*pxParameterStringLength)++; //计算该单词的长度
                                pcCommandString++;            //下一个字符
                            }

                            if (*pxParameterStringLength == 0) //结束了
                            {
                                pcReturn = NULL;
                            }

                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                return pcReturn;
            }

            //获取参数数量
            int8_t prvGetNumberOfParameters(const char *pcCommandString)
            {
                int8_t cParameters = 0;
                BaseType_t xLastCharacterWasSpace = pdFALSE;

                /* Count the number of space delimited words in pcCommandString. */
                while (*pcCommandString != 0x00)
                {
                    if ((*pcCommandString) == ' ')
                    {
                        if (xLastCharacterWasSpace != pdTRUE)
                        {
                            cParameters++;
                            xLastCharacterWasSpace = pdTRUE;
                        }
                    }
                    else
                    {
                        xLastCharacterWasSpace = pdFALSE;
                    }

                    pcCommandString++;
                }

                /* If the command string ended with spaces, then there will have been too
        many parameters counted. */
                if (xLastCharacterWasSpace == pdTRUE)
                {
                    cParameters--;
                }

                /* The value returned is one less than the number of space delimited words,
        as the first word should be the command itself. */
                return cParameters;
            }

            //多次
            bool prvHelpCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
            {
                static const cmd_list *pxCommand = NULL; //每执行一次就指向下一个。可改可存
                bool xReturn;

                (void)pcCommandString;

                if (pxCommand == NULL)
                {
                    /* Reset the pxCommand pointer back to the start of the list. */
                    pxCommand = &xRegisteredCommands;
                }

                /* Return the next command help string, before moving the pointer on to
        the next command in the list. */
                strncpy(pcWriteBuffer, pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen);
                pxCommand = pxCommand->pxNext;

                if (pxCommand == NULL)
                {
                    /* There are no more commands in the list, so there will be no more
            strings to return after this one and pdFALSE should be returned. */
                    xReturn = pdFALSE;
                }
                else
                {
                    xReturn = pdTRUE;
                }

                return xReturn;
            }

            //一次
            bool prvTaskStatsCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
            {
                const char *const pcHeader = "     State   Priority  Stack    #\r\n************************************************\r\n";
                BaseType_t xSpacePadding;

                /* Remove compile time warnings about unused parameters, and check the
        write buffer is not NULL.  NOTE - for simplicity, this example assumes the
        write buffer length is adequate, so does not check for buffer overflows. */
                (void)pcCommandString;
                (void)xWriteBufferLen;
                configASSERT(pcWriteBuffer);

                /* Generate a table of task stats. */
                strcpy(pcWriteBuffer, "Task");
                pcWriteBuffer += strlen(pcWriteBuffer);

                /* Minus three for the null terminator and half the number of characters in
        "Task" so the column lines up with the centre of the heading. */
                configASSERT(configMAX_TASK_NAME_LEN > 3);
                //在"Task"后面添加最大配置的数量的空格
                for (xSpacePadding = strlen("Task"); xSpacePadding < (configMAX_TASK_NAME_LEN - 3); xSpacePadding++)
                {
                    /* Add a space to align columns after the task's name. */
                    *pcWriteBuffer = ' ';
                    pcWriteBuffer++;

                    /* 确保最后一个字符为空，可能是防止某些问题。无直接作用 */
                    *pcWriteBuffer = 0x00;
                }
                strcpy(pcWriteBuffer, pcHeader);
                vTaskList(pcWriteBuffer + strlen(pcHeader));

                /* There is no more data to return after this single string, so return
        pdFALSE. */
                return pdFALSE;
            }

            //一次
            bool prvQueryHeapCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
            {
                /* Remove compile time warnings about unused parameters, and check the
        write buffer is not NULL.  NOTE - for simplicity, this example assumes the
        write buffer length is adequate, so does not check for buffer overflows. */
                (void)pcCommandString;
                (void)xWriteBufferLen;
                configASSERT(pcWriteBuffer);

                sprintf(pcWriteBuffer, "Current free heap %d bytes, minimum ever free heap %d bytes\r\n", (int)xPortGetFreeHeapSize(), (int)xPortGetMinimumEverFreeHeapSize());

                /* There is no more data to return after this single string, so return
        pdFALSE. */
                return pdFALSE;
            }

            //多次
            bool prvParameterEchoCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
            {
                const char *pcParameter; //参数的位置
                BaseType_t xParameterStringLength, xReturn;
                static UBaseType_t uxParameterNumber = 0; //第几个参数。可改可存

                /* Remove compile time warnings about unused parameters, and check the
        write buffer is not NULL.  NOTE - for simplicity, this example assumes the
        write buffer length is adequate, so does not check for buffer overflows. */
                (void)pcCommandString;
                (void)xWriteBufferLen;
                configASSERT(pcWriteBuffer);

                static int32_t argBuffer[20]; //参数暂存
                static uint8_t count;         //参数计数

                if (uxParameterNumber == 0)
                {
                    /* The first time the function is called after the command has been
            entered just a header string is returned. */
                    sprintf(pcWriteBuffer, "The parameters were:\r\n");

                    /* Next time the function is called the first parameter will be echoed
            back. */
                    uxParameterNumber = 1U;

                    /* There is more data to be returned as no parameters have been echoed
            back yet. */
                    xReturn = pdPASS;
                }
                else
                {
                    /* Obtain the parameter string. */
                    pcParameter = FreeRTOS_CLIGetParameter(
                        pcCommandString,        /* The command string itself. */
                        uxParameterNumber,      /* 想要那个序号的参数 */
                        &xParameterStringLength /* Store the parameter string length. */
                    );

                    if (pcParameter != NULL)
                    {
                        /* Return the parameter string. */
                        memset(pcWriteBuffer, 0x00, xWriteBufferLen); //清空输出缓存
                        sprintf(pcWriteBuffer, "%d: ", (int)uxParameterNumber);
                        strncat(pcWriteBuffer, (char *)pcParameter, (size_t)xParameterStringLength); //参数的字符串本身
                        strncat(pcWriteBuffer, "\r\n", strlen("\r\n") + 1);

                        /* There might be more parameters to return after this one. */
                        xReturn = pdTRUE;
                        uxParameterNumber++;

                        if (echoDataQueue)
                        {
                            // int32_t buffer = atoi(pcParameter);
                            argBuffer[count] = atoi(pcParameter);
                            count++;
                            // osMessageQueuePut(echoDataQueue, &buffer, 0, osWaitForever);
                        }
                    }
                    else
                    {
                        /* No more parameters were found.  Make sure the write buffer does
                not contain a valid string. */
                        pcWriteBuffer[0] = 0x00;

                        /* No more data to return. */
                        xReturn = pdFALSE;

                        if (echoDataQueue)
                        {
                            // uint8_t &&buffer = uxParameterNumber - 1;
                            // osMessageQueuePut(echoDataSizeQueue, &buffer, 0, 0);
                            osMessageQueuePut(echoDataQueue, &count, 0, osWaitForever); //参数个数
                            for (uint8_t i = 0; i < count; i++)
                                osMessageQueuePut(echoDataQueue, &argBuffer[i], 0, osWaitForever);
                            count = 0;
                        }

                        /* Start over the next time this command is executed. */
                        uxParameterNumber = 0;
                    }
                }

                return xReturn;
            }

            void cliClass::vRegisterSampleCLICommands()
            {
                if (registerFlag)
                    return;
                registerFlag = true;

                // FreeRTOS_CLIRegisterCommand(&xTaskStats);
                FreeRTOS_CLIRegisterCommand(&xParameterEcho);
                // FreeRTOS_CLIRegisterCommand(&xQueryHeap);
            }
        } // namespace cliNamespace
    }     // namespace parserNamespace
} // namespace xiagb